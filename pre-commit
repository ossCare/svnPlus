#!/usr/bin/perl -w
################################################################################
#  Author:      Joseph C. Pietras - Joseph.Pietras@gmail.com
#  License:     GNU GENERAL PUBLIC LICENSE Version 2
#  GitHub:      https://github.com/ossCare/svnPlus.git
#  SourceForge: TBD
################################################################################
# ENTER: INITIALIZE THE PROGRAM
use warnings;
use strict;
use Cwd 'abs_path'; # to be able to get full path to this file
# LEAVE: INITIALIZE THE PROGRAM
################################################################################

################################################################################
# ENTER: find the name of this program and its folder
my $NAME=&abs_path($0);         # print "NAME=$NAME\n";

#  $NAME =~ s@/@\\@g;           # change all "/" to "\" chars WINDOWS?
my $DIRE = $NAME;               # init to full path for finding folder we live
$NAME =~ s@.*\\@@;           # print "NAME=$NAME\n";
$NAME =~ s@.*/@@;            # print "NAME=$NAME\n";
$DIRE =~ s@\\[^\\][^\\]*$@@; # print "DIRE=$DIRE\n";
$DIRE =~ s@/[^/][^/]*$@@;    # print "DIRE=$DIRE\n";
# LEAVE: find the name of this program and its folder
################################################################################

################################################################################
# ENTER: CONFIG FILE, PRE-CONFIG FILE and REQUIRED SUBROUTINE FILE
my $CFGF = "$DIRE/tagprotect.cfg";     # the name of the config file itself
my $PCFG = "$DIRE/tagprotect.cfg.pl";  # the name of the "pre-compiled" file
require "$DIRE/tagprotect.pl";         # subroutines, read them in
# LEAVE: CONFIG FILE, PRE-CONFIG FILE and REQUIRED SUBROUTINE FILE
################################################################################

################################################################################
# ENTER: PARSE COMMAND LINE AND CONFIGURATION FILE
my ( %RO_CLI ) = &ParseCLI($NAME, $CFGF, $PCFG);
my ( %ROconf ) = &ParseCFG($NAME, \%RO_CLI);  # some of $CFGF now in %RO_CLI
# LEAVE: PARSE COMMAND LINE AND CONFIGURATION FILE
################################################################################

################################################################################
# ENTER: get the debug level for use in this file from the command line data
#       (were it is kept even though it likly came from the configuation file).
my $dbglvl     = &DebugLevel(\%RO_CLI);
#{
#    my $fn = "/tmp/${NAME}-$$-out";
#    my $oh;
#    open $oh, ">", $fn;
#    print $oh '$dbglvl=' . "$dbglvl\n";
#    close $oh;
#}
# LEAVE:
################################################################################

################################################################################
# ENTER: if debugging just the above Parse subroutines you should exit here
#        because next we read the data provided by subversion and if you are
#        not under subversion this script might hang or generate useless error
#        messages.
if ( &JustCFGParse(\%RO_CLI) == 1)
{
    print STDERR "$NAME: exit because just parse command line is in effect\n" if ( $dbglvl > 0 );
    exit 0;
}
# LEAVE:
################################################################################

## # SINCE NOT USED JUST DON'T BOTHER
## ################################################################################
## # ENTER: READ "LOCK TOKENS" FROM STDIN -> NOTE: script doesn't use the locks
## # to run from command line redirect stdin with "< /dev/null"
## #y $lockTokens  = ""; # can get "strict" warnings in debug without this
## my $lockTokens  = do { local $/ = ""; <STDIN> };
## $lockTokens //= "";
## print STDERR "$NAME: " . ' $lockTokens= ' . '"' . $lockTokens . '"' . "\n" if ( $dbglvl > 4);
## # LEAVE: READ "LOCK TOKENS" FROM STDIN -> NOTE: script doesn't use the locks
## ################################################################################

# is this really needed?
my $svnAuthor = ""; # because of strict init to blank
my @svnCommit = (); # because of strict init to blank
$svnAuthor = &GetSvnAuthor($NAME, \%RO_CLI);
@svnCommit = &GetSvnCommit($NAME, \%RO_CLI);

if ( &SimplyAllow(\%RO_CLI, \%ROconf, \@svnCommit) == 1 )
{

    # if the commit is ok, because it does impact protected
    # folders, but debug is wanted must exit NON-zero, which
    # causes the commit to fail but the client gets the standard
    # error.  A zero exit causes the STDERR to be squashed.
    # If any "True" errors occured, "SimplyAllow" will have
    # printed them to standard error and would have returned 0.
    if ( $dbglvl > 0 )
    {
        print STDERR "$NAME:  SimplyAllow succeeded but exiting 1 because debug is enabled\n";
        exit 1;
    }
    exit 0;
}
if ( &AllowCommit($NAME, \%RO_CLI, \%ROconf, \@svnCommit, $svnAuthor) == 1)
{

    # if the commit is ok, i.e.: it is allowed, but debug is wanted
    # must exit NON-zero, which causes the commit to fail but the
    # client gets the standard error.  A zero exit causes the STDERR
    # to be squashed.    If any "True" errors occurred, "AllowCommit"
    # will have printed them to standard error and would have returned 0.
    if ( $dbglvl > 0 )
    {
        print STDERR "$NAME:  AllowCommit succeeded but exiting 1 because debug is enabled\n";
        exit 1;
    }
    exit 0;
}

# commit is not allowed "AllowCommit" has already output the reason
print STDERR "$NAME:  exit 1 this is a true prevent commit condition\n" if ( $dbglvl > 0 );
exit 1;
